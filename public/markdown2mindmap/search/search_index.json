{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#markdown2mindmap","title":"Markdown2mindmap","text":"<p>This small application converts Markdown files to Mind maps.</p> <p>It is written in Clojure and uses:</p> <ul> <li>Cybermonday   to convert markdown text to a hiccup AST.</li> <li>PlantUML to create the images.</li> </ul> <p>The two main objectives for this app are:</p> <ul> <li>quick and easy production of PNG images;</li> <li>use any independant markdown document as source.   The hiccup AST provided by Cybermonday   enables the processing and filtering of markdown elements.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>FIXME: explanation</p> <p>Download from https://github.com/obarbeau/markdown2mindmap</p>"},{"location":"#usage","title":"Usage","text":"<p>FIXME: update this part</p> <p>This project uses the <code>seancorfield/build-clj</code> library and <code>build.clj</code> file. Use <code>clj -T:dev:build &lt;task-name&gt;</code> for all these tasks.</p> <p>Run the application: see usage</p> <p>Run the project's tests (this will generate test images in the output directory):</p> <pre><code>clojure -T:dev:build test\n</code></pre> <p>G\u00e9nerate the project's documentation:</p> <pre><code>clojure -T:dev:build codox\n</code></pre> <p>Run the project's CI pipeline and build an uberjar:</p> <pre><code>clojure -T:dev:build ci\n</code></pre> <p>This will produce an updated <code>pom.xml</code> file with synchronized dependencies inside the <code>META-INF</code> directory inside <code>target/classes</code> and the uberjar in <code>target</code>. You can update the version (and SCM tag) information in generated <code>pom.xml</code> by updating <code>build.clj</code>.</p> <p>If you don't want the <code>pom.xml</code> file in your project, you can remove it. The <code>ci</code> task will still generate a minimal <code>pom.xml</code> as part of the <code>uber</code> task, unless you remove <code>version</code> from <code>build.clj</code>.</p> <p>Run that uberjar:</p> <pre><code>java -jar target/markdown2mindmap-0.1.0-SNAPSHOT.jar\n</code></pre> <p>If you remove <code>version</code> from <code>build.clj</code>, the uberjar will become <code>target/markdown2mindmap-standalone.jar</code>.</p>"},{"location":"#options","title":"Options","text":"<p>FIXME: listing of options this app accepts.</p>"},{"location":"#examples","title":"Examples","text":"<p>...</p>"},{"location":"#todo","title":"Todo","text":"<ul> <li>allows nested text modifiers</li> </ul>"},{"location":"#license","title":"License","text":"<p>Copyright \u00a9 2021 Olivier Barbeau</p> <p>Distributed under the Eclipse Public License either version 1.0 or (at your option) any later version.</p>"},{"location":"markdown2mindmap/core/","title":"markdown2mindmap.core","text":"(<code>ns</code>) <pre><code>(ns markdown2mindmap.core\n(:require [clojure.string :as str]\n[clojure.tools.cli :refer [parse-opts]]\n[markdown2mindmap.transform :as m2mtransform])\n(:gen-class))\n</code></pre>"},{"location":"markdown2mindmap/core/#cli-options","title":"<code>cli-options</code>","text":"(<code>def</code>) <pre><code>(def cli-options\n[[\"-t\" \"--type OUTPUT-TYPE\"\n\"Either 'svg' (default) or 'png'.\"\n:default \"svg\"\n:parse-fn #(str/lower-case %)\n:validate [#(#{\"svg\" \"png\"} %) \"Either 'svg' or 'png' format.\"]]\n[nil \"--style STYLE-FILE\" \"Apply custom style to mindmap\"]\n[nil \"--with-puml\" \"Generate intermediate puml file\"]\n[\"-h\" \"--help\"]])\n</code></pre>"},{"location":"markdown2mindmap/core/#usage","title":"<code>usage</code>","text":"<pre><code>(usage options-summary)\n</code></pre> (<code>defn</code>) <pre><code>(defn usage [options-summary]\n(-&gt;&gt; [\"Converts Markdown files to Mind maps.\"\n\"Usage: markdown2mindmap [options] convert &lt;input-file&gt; &lt;output-dir&gt;\"\n\"       markdown2mindmap list-all-fonts [output-file]\"\n\"Options:\"\noptions-summary\n\"Actions:\"\n\"  convert         Converts markdown file to mindmap.\"\n\"  list-all-fonts  Creates an SVG image listing all fonts available on the system.\"\n\"                  output-file defaults to ./all-fonts.svg\"\n\"Examples: clojure -M:run-m convert --style resources/custom.css test-resources/input-07.md .\"\n\"          clojure -M:run-m list-all-fonts\"]\n(str/join \\newline)))\n</code></pre>"},{"location":"markdown2mindmap/core/#error-msg","title":"<code>error-msg</code>","text":"<pre><code>(error-msg errors)\n</code></pre> (<code>defn</code>) <pre><code>(defn error-msg [errors]\n(str \"The following errors occurred while parsing your command:\\n\\n\"\n(str/join \\newline errors)))\n</code></pre>"},{"location":"markdown2mindmap/core/#exit","title":"<code>exit</code>","text":"<pre><code>(exit status msg)\n</code></pre> (<code>defn</code>) <pre><code>(defn exit [status msg]\n(println msg)\n(System/exit status))\n</code></pre>"},{"location":"markdown2mindmap/core/#validate-args","title":"<code>validate-args</code>","text":"<p>Validate command line arguments. Either return a map indicating the program   should exit (with a error message, and optional ok status), or a map   indicating the action the program should take and the options provided.</p> <pre><code>(validate-args args)\n</code></pre> (<code>defn</code>) <pre><code>(defn validate-args\n[args]\n(let [{:keys [options arguments errors summary]} (parse-opts args cli-options)\nnbargs (count arguments)\n[action &amp; restargs] arguments]\n(cond\n;; help =&gt; exit OK with usage summary\n(:help options)\n{:exit-message (usage summary) :ok? true}\n;; errors =&gt; exit with description of errors\nerrors\n{:exit-message (error-msg errors)}\n;; custom validation on arguments\n(or\n(and (&lt;= nbargs 2)\n(#{\"list-all-fonts\"} action))\n(and (= 3 nbargs)\n(#{\"convert\"} action)))\n{:action action :arguments restargs :options options}\n;; failed custom validation =&gt; exit with usage summary\n:else\n{:exit-message (usage summary)})))\n</code></pre>"},{"location":"markdown2mindmap/core/#-main","title":"<code>-main</code>","text":"<pre><code>(-main &amp; args)\n</code></pre> (<code>defn</code>) <pre><code>(defn -main [&amp; args]\n(let [{:keys [action options arguments exit-message ok?]} (validate-args args)\n[input-file output-directory] arguments\n[output-file] arguments]\n(if exit-message\n(exit (if ok? 0 1) exit-message)\n(case action\n\"convert\"        (m2mtransform/md-&gt;mindmap input-file\noutput-directory\noptions)\n\"list-all-fonts\" (m2mtransform/list-all-fonts\n(or output-file \"./all-fonts.svg\")))))\n(exit 0 \":ok\"))\n</code></pre>"},{"location":"markdown2mindmap/enter/","title":"markdown2mindmap.enter","text":"(<code>ns</code>) <pre><code>(ns markdown2mindmap.enter\n(:require [cybermonday.ir]\n[markdown2mindmap.log :as m2mlog]\n[taoensso.timbre :as t :refer [info]]))\n</code></pre>"},{"location":"markdown2mindmap/enter/#log-enter","title":"<code>log-enter</code>","text":"(<code>defn-</code>) <pre><code>(defn- log-enter\n[result ctype]\n(info (t/color-str :blue (str \"&gt;&gt;enter-\" (name ctype)))\n\"\\n \" (select-keys @result m2mlog/log-keys)))\n</code></pre>"},{"location":"markdown2mindmap/enter/#now-inside","title":"<code>now-inside</code>","text":"<p>We are inside a <code>ctype</code> element. Sets the <code>inside</code> flag to true    and the children.</p> (<code>defn-</code>) <pre><code>(defn- now-inside\n[result ctype children]\n(swap! result assoc-in [ctype :inside] true)\n(if (number? children)\n(swap! result assoc-in [ctype :children] children)\n(swap! result update-in [ctype :children] children))\n(log-enter result ctype))\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-heading","title":"<code>enter-heading</code>","text":"<p>Enters a heading element. Level is given in attributes.</p> <pre><code>(enter-heading result [_elt-name attributes &amp; children :as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-heading\n[result [_elt-name attributes &amp; children :as x]]\n(swap! result assoc-in [:heading :level] (:level attributes))\n(now-inside result :heading (count children))\nx)\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-ol-ul","title":"<code>enter-ol-ul</code>","text":"<p>Enters a list, ordered or not.</p> <pre><code>(enter-ol-ul result [_elt-name _attributes &amp; children :as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-ol-ul\n[result [_elt-name _attributes &amp; children :as x]]\n(now-inside result :ol-ul #(cons (count children) %))\nx)\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-li","title":"<code>enter-li</code>","text":"<p>Enters a list element. The number of children is forced to one.    Nesting of ol/ul is not managed by li element.</p> <pre><code>(enter-li result [:as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-li\n[result [:as x]]\n(now-inside result :li 1)\nx)\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-p","title":"<code>enter-p</code>","text":"<p>Enters a paragraph.</p> <pre><code>(enter-p result [_elt-name _attributes &amp; children :as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-p\n[result [_elt-name _attributes &amp; children :as x]]\n(now-inside result :p (count children))\nx)\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-em","title":"<code>enter-em</code>","text":"<p>Enters an 'emphasize' modifier.</p> <pre><code>(enter-em result [:as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-em\n[result [:as x]]\n(swap! result assoc :modifier :em)\n(log-enter result :em)\nx)\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-s","title":"<code>enter-s</code>","text":"<p>Enters a 'strike' modifier.</p> <pre><code>(enter-s result [:as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-s\n[result [:as x]]\n(swap! result assoc :modifier :s)\n(log-enter result :s)\nx)\n</code></pre>"},{"location":"markdown2mindmap/enter/#enter-strong","title":"<code>enter-strong</code>","text":"<p>Enters a 'strong' modifier.</p> <pre><code>(enter-strong result [:as x])\n</code></pre> (<code>defn</code>) <pre><code>(defn enter-strong\n[result [:as x]]\n(swap! result assoc :modifier :strong)\n(log-enter result :strong)\nx)\n</code></pre>"},{"location":"markdown2mindmap/exit/","title":"markdown2mindmap.exit","text":"(<code>ns</code>) <pre><code>(ns markdown2mindmap.exit\n(:require [markdown2mindmap.log :as m2mlog]\n[taoensso.timbre :as t :refer [info]]))\n</code></pre>"},{"location":"markdown2mindmap/exit/#last-simple-child","title":"<code>last-simple-child?</code>","text":"<p>Returns a vector with 2 values:    1. True if it is the last child of a non-nestable element.    2. new number of children for this non-nestable element or zero.</p> (<code>defn-</code>) <pre><code>(defn- last-simple-child?\n[children]\n(let [new-children (dec children)]\n[(zero? new-children) new-children]))\n</code></pre>"},{"location":"markdown2mindmap/exit/#last-nested-child","title":"<code>last-nested-child?</code>","text":"<p>Returns a vector with 2 values:    1. is it the last child of a nestable element (like ol/ul)?    2. rest of children or nil.</p> (<code>defn-</code>) <pre><code>(defn- last-nested-child?\n[children]\n(let [[child1 &amp; rest] children\nchild1dec (dec (or child1 1))]\n[(zero? child1dec) (if (zero? child1dec)\nrest\n(cons child1dec rest))]))\n</code></pre>"},{"location":"markdown2mindmap/exit/#last-child","title":"<code>last-child?</code>","text":"<p>Returns a vector with 2 values:    1. is it the last child of the element of type <code>ctype</code>.    2. the new children number/list or nil.</p> (<code>defn-</code>) <pre><code>(defn- last-child?\n[result ctype]\n(let [children (get-in @result [ctype :children])\n[last? new-children] (if (number? children)\n(last-simple-child? children)\n(last-nested-child? children))]\n[last? new-children]))\n</code></pre>"},{"location":"markdown2mindmap/exit/#now-outside","title":"<code>now-outside?</code>","text":"<p>Returns true if we are now completely outside of this (nested) element?</p> (<code>defn-</code>) <pre><code>(defn- now-outside?\n[result ctype]\n(let [[_last? new-children] (last-child? result ctype)]\n(or (nil? new-children)\n(and (number? new-children) (zero? new-children)))))\n</code></pre>"},{"location":"markdown2mindmap/exit/#inside-and-last","title":"<code>inside-and-last?</code>","text":"<p>If we are we inside a <code>ctype</code> element, returns <code>last-child?</code> answer,   otherwise nil.</p> (<code>defn-</code>) <pre><code>(defn- inside-and-last?\n[result ctype]\n(when (get-in @result [ctype :inside])\n(last-child? result ctype)))\n</code></pre>"},{"location":"markdown2mindmap/exit/#exit","title":"<code>exit</code>","text":"<p>Set <code>inside</code> flag to false    only if this was the last child of all (nested) elements.</p> (<code>defn-</code>) <pre><code>(defn- exit\n[result ctype now-outside?]\n(when now-outside?\n(swap! result assoc-in [ctype :inside] false))\n(info (t/color-str :purple (str \"&lt;&lt;exit-\" (name ctype)))\n(select-keys @result m2mlog/log-keys)))\n</code></pre>"},{"location":"markdown2mindmap/exit/#exit-if-required","title":"<code>exit-if-required</code>","text":"<p>If we are we inside a <code>ctype</code> element, sets the new number of children.   If it wad the last child, execute the <code>exit-fn</code>.</p> (<code>defn-</code>) <pre><code>(defn- exit-if-required\n[result ctype exit-fn]\n(when-let [[last? new-children] (inside-and-last? result ctype)]\n(swap! result assoc-in [ctype :children] new-children)\n(when last?\n(exit-fn result))))\n</code></pre>"},{"location":"markdown2mindmap/exit/#exit-heading","title":"<code>exit-heading</code>","text":"<p>Exit a heading element. Conj current buffer to puml text.</p> (<code>defn-</code>) <pre><code>(defn- exit-heading\n[result]\n(let [text (-&gt; (get-in @result [:heading :level])\n(repeat \"*\")\n(concat \" \" (:buffer @result))\n(#(apply str %)))]\n(swap! result update :puml conj text)\n(swap! result assoc :buffer \"\"))\n(exit result :heading true))\n</code></pre>"},{"location":"markdown2mindmap/exit/#exit-ol-ul","title":"<code>exit-ol-ul</code>","text":"<p>Exit a list, ordered or not.</p> (<code>defn-</code>) <pre><code>(defn- exit-ol-ul\n[result]\n(exit result :ol-ul (now-outside? result :ol-ul)))\n</code></pre>"},{"location":"markdown2mindmap/exit/#exit-li","title":"<code>exit-li</code>","text":"<p>Exit a list element.   Use the level of the list added to the level of containing heading.</p> (<code>defn-</code>) <pre><code>(defn- exit-li\n[result]\n(let [level-heading (get-in @result [:heading :level])\nlevel-ol-ul (count (get-in @result [:ol-ul :children]))\nlevel-total (+ level-heading level-ol-ul)\ntext (-&gt; (repeat level-total  \"*\")\n(concat  \"_ \" (:buffer @result))\n(#(apply str %)))]\n(swap! result update :puml conj text)\n(swap! result assoc :buffer \"\")\n(exit result :li true)\n(exit-if-required result :ol-ul exit-ol-ul)))\n</code></pre>"},{"location":"markdown2mindmap/exit/#exit-p","title":"<code>exit-p</code>","text":"<p>Exit a paragraph. The buffer is deleted if it has not been used.</p> (<code>defn-</code>) <pre><code>(defn- exit-p\n[result]\n(exit result :p true)\n(exit-if-required result :li exit-li)\n(swap! result assoc :buffer \"\"))\n</code></pre>"},{"location":"markdown2mindmap/exit/#apply-modifier","title":"<code>apply-modifier</code>","text":"<p>Applies the current modifier to the string.</p> (<code>defn-</code>) <pre><code>(defn- apply-modifier\n[result s]\n(let [modifier (:modifier @result)]\n(swap! result assoc :modifier nil)\n(case modifier\n:em (format \"&lt;i&gt;%s&lt;/i&gt;\" s)\n:strong (format \"&lt;b&gt;%s&lt;/b&gt;\" s)\n:s (format \"&lt;s&gt;%s&lt;/s&gt;\" s)\ns)))\n</code></pre>"},{"location":"markdown2mindmap/exit/#process-string","title":"<code>process-string</code>","text":"<p>If the <code>ignore-string</code> flag is not true,   adds this string to the buffer, applying eventual modifier.   Then checks if this string was the last child of a heading or paragraph   and exit them if required.</p> <pre><code>(process-string result s)\n</code></pre> (<code>defn</code>) <pre><code>(defn process-string\n[result s]\n(if (:ignore-string @result)\n(info \"ignore string: \" s)\n(do\n(swap! result update-in [:buffer] str (apply-modifier result s))\n(info (t/color-str :green \"&gt;&gt;process-string\") s)))\n(swap! result assoc :ignore-string false)\n(exit-if-required result :heading exit-heading)\n(exit-if-required result :p exit-p)\n(info (t/color-str :green \"&lt;&lt;process-string\") \"\\n \"\n(select-keys @result m2mlog/log-keys))\ns)\n</code></pre>"},{"location":"markdown2mindmap/exit/#through-slb","title":"<code>through-slb</code>","text":"<p>Pass through a soft line break. Set the <code>ignore-string</code> flag to true.   Then checks if this element was the last child of a paragraph   and exit if required.</p> <pre><code>(through-slb result x)\n</code></pre> (<code>defn</code>) <pre><code>(defn through-slb\n[result x]\n(when (get-in @result [:ol-ul :inside])\n(swap! result assoc :ignore-string true))\n(exit-if-required result :p exit-p)\nx)\n</code></pre>"},{"location":"markdown2mindmap/log/","title":"markdown2mindmap.log","text":"(<code>ns</code>) <pre><code>(ns markdown2mindmap.log\n(:require [cybermonday.ir]\n[taoensso.encore :as enc]\n[taoensso.timbre :as t]\n[taoensso.timbre.appenders.core :as appenders]))\n</code></pre>"},{"location":"markdown2mindmap/log/#log-file-name","title":"<code>log-file-name</code>","text":"(<code>def</code>) <pre><code>(def log-file-name \"./output/markdown2mindmap.log\")\n(def log-keys [:ol-ul :li :p :heading :modifier :buffer :ignore-string])\n</code></pre>"},{"location":"markdown2mindmap/log/#timestamp-opts-pattern-output-fn-fn-data-let-keys-level-err-msg_-ns-str-file-hostname_-timestamp_-line-data-str-force-msg_-when-let-err-err-str-encsystem-newline-tstacktrace-err-appenders-spit-appendersspit-appender-fname-log-file-name-println-enabled-false","title":"<code>{:timestamp-opts {:pattern \"\"}, :output-fn (fn ([data] (let [{:keys [level ?err msg_ ?ns-str ?file hostname_ timestamp_ ?line]} data] (str (force msg_) (when-let [err ?err] (str enc/system-newline (t/stacktrace err))))))), :appenders {:spit (appenders/spit-appender {:fname log-file-name}), :println {:enabled? false}}}</code>","text":"(<code>t/merge-config!</code>) <pre><code>(t/merge-config!\n{:timestamp-opts  {:pattern \"\"}\n:output-fn\n(fn  ([data]\n(let [{:keys [level ?err #_vargs msg_ ?ns-str ?file hostname_\ntimestamp_ ?line]} data]\n(str\n;; nothing else than message!\n;;(when-let [ts (force timestamp_)] (str ts \" \"))\n;;(force hostname_)  \" \"\n;;(str/upper-case (name level))  \" \"\n;;\"[\" (or ?ns-str ?file \"?\") \":\" (or ?line \"?\") \"] - \"\n(force msg_)\n(when-let [err ?err]\n(str enc/system-newline (t/stacktrace err)))))))\n:appenders {:spit (appenders/spit-appender {:fname log-file-name})\n:println {:enabled? false}}})\n</code></pre> <p>(info t/config)</p>"},{"location":"markdown2mindmap/transform/","title":"markdown2mindmap.transform","text":"(<code>ns</code>) <pre><code>(ns markdown2mindmap.transform\n(:require [clojure.java.io :as io]\n[clojure.string :as str]\n[clojure.walk :refer [prewalk]]\n[cybermonday.ir]\n[clojure.edn :as edn]\n[markdown2mindmap.enter :as m2menter]\n[markdown2mindmap.exit :as m2mexit]\n[puget.printer :as puget]\n[taoensso.timbre :as t :refer [info infof]])\n(:import (java.io FileOutputStream)\n(net.sourceforge.plantuml SourceStringReader\nFileFormatOption\nFileFormat)))\n</code></pre>"},{"location":"markdown2mindmap/transform/#walk-fn","title":"<code>walk-fn</code>","text":"(<code>defn-</code>) <pre><code>(defn- walk-fn\n[result x]\n(cond\n(vector? x)\n(let [[elt-name _attributes &amp; children] x]\n(infof \"\\nvector with %d children=%s\" (count children) x)\n(case elt-name\n:div ;;root div\nx\n:markdown/heading\n(m2menter/enter-heading result x)\n:ul\n(m2menter/enter-ol-ul result x)\n:ol\n(m2menter/enter-ol-ul result x)\n:markdown/bullet-list-item\n(m2menter/enter-li result x)\n:markdown/ordered-list-item\n(m2menter/enter-li result x)\n:markdown/soft-line-break\n(m2mexit/through-slb result x)\n:p\n(m2menter/enter-p result x)\n:em\n(m2menter/enter-em result x)\n:s\n(m2menter/enter-s result x)\n:strong\n(m2menter/enter-strong result x)\n;; else\n(do\n(info \"Not yet processed: \" x)\nx)))\n(string? x)\n(m2mexit/process-string result x)\n#_#_:else\n(infof \"What is it? %s\" x)))\n</code></pre>"},{"location":"markdown2mindmap/transform/#walk-hiccup","title":"<code>walk-hiccup</code>","text":"<p>Walk function to process hiccup data.</p> (<code>defn-</code>) <pre><code>(defn- walk-hiccup\n[hiccup-data]\n(let [result (atom {})]\n(prewalk (partial walk-fn result) hiccup-data)\n@result))\n</code></pre>"},{"location":"markdown2mindmap/transform/#-puml2","title":"<code>-&gt;puml2</code>","text":"<p>Wraps puml text to puml syntax.</p> <pre><code>(-&gt;puml2 styles puml)\n</code></pre> (<code>defn</code>) <pre><code>(defn -&gt;puml2\n[styles puml]\n(str/join\n\\newline\n(list\n\"@startmindmap\"\nstyles\npuml\n\"@endmindmap\")))\n</code></pre>"},{"location":"markdown2mindmap/transform/#create-image","title":"<code>create-image!</code>","text":"<p>Generates an image from puml text.</p> (<code>defn-</code>) <pre><code>(defn- create-image!\n[output-file type puml2]\n(let [out (FileOutputStream. (io/file output-file))\nformat (-&gt;&gt; type\nstr/upper-case\n(.getField FileFormat)\n;;The nil is there because you are getting a static field,\n;; rather than a member field of a particular object.\n(#(.get ^java.lang.reflect.Field % nil))\nFileFormatOption.)]\n(-&gt; (SourceStringReader. puml2)\n(.outputImage out format))\n(.close out)))\n</code></pre>"},{"location":"markdown2mindmap/transform/#md-hiccup","title":"<code>md-&gt;hiccup</code>","text":"<p>Converts markdown data to hiccup AST with cybermonday.</p> <pre><code>(md-&gt;hiccup data)\n</code></pre> (<code>defn</code>) <pre><code>(defn md-&gt;hiccup\n[data]\n(cybermonday.ir/md-to-ir data))\n</code></pre>"},{"location":"markdown2mindmap/transform/#md-hiccup-file","title":"<code>md-&gt;hiccup-file</code>","text":"<p>Generates a hiccup (edn) file from a markdown file.</p> <pre><code>(md-&gt;hiccup-file input-file output-file)\n</code></pre> (<code>defn</code>) <pre><code>(defn md-&gt;hiccup-file\n[input-file output-file]\n(-&gt;&gt; input-file\nslurp\nmd-&gt;hiccup\npuget/pprint-str\n(spit output-file)))\n</code></pre>"},{"location":"markdown2mindmap/transform/#hiccup-puml","title":"<code>hiccup-&gt;puml</code>","text":"<p>Convert hiccup data to puml text.</p> <pre><code>(hiccup-&gt;puml hiccup-data)\n</code></pre> (<code>defn</code>) <pre><code>(defn hiccup-&gt;puml\n[hiccup-data]\n(-&gt;&gt; hiccup-data\nwalk-hiccup\n:puml\nreverse\n(str/join \"\\n\")))\n</code></pre>"},{"location":"markdown2mindmap/transform/#md-mindmap","title":"<code>md-&gt;mindmap</code>","text":"<p>Generates an mindmap image (with the <code>type</code> format) from a markdown file.</p> <pre><code>(md-&gt;mindmap input-file output-directory {:keys [type style with-puml]})\n</code></pre> (<code>defn</code>) <pre><code>#_(defn hiccup-&gt;puml-file\n\"Generates a puml file from an hiccup file.\"\n[input-file output-file]\n(-&gt;&gt; input-file\nslurp\nedn/read-string\nhiccup-&gt;puml\n(spit output-file)))\n(defn md-&gt;mindmap\n[input-file output-directory {:keys [type style with-puml]}]\n(let [output-name (-&gt; input-file\n;; keeps only filename without extension\n(str/replace #\"(?i)\\.md\" \"\")\n;; nor path\n(str/replace #\".*/\" \"\"))\noutput-img (-&gt; output-name\n;; adds selected extension\n(str \".\" type)\n(#(io/file output-directory %)))\noutput-puml (-&gt; output-name\n(str \".puml\")\n(#(io/file output-directory %)))\nstyles (when style (slurp style))\npuml (-&gt;&gt; input-file\nslurp\nmd-&gt;hiccup\nhiccup-&gt;puml\n(-&gt;puml2 styles))]\n(when with-puml\n(spit output-puml puml))\n(create-image! output-img type puml)))\n</code></pre>"},{"location":"markdown2mindmap/transform/#list-all-fonts","title":"<code>list-all-fonts</code>","text":"<p>Creates an SVG image listing all fonts available on the system.</p> <pre><code>(list-all-fonts output-file)\n</code></pre> (<code>defn</code>) <pre><code>(defn list-all-fonts\n[output-file]\n(create-image! output-file \"svg\" (str/join\n\\newline [\"@startuml\"\n\"listfonts\"\n\"@enduml\"])))\n</code></pre>"}]}